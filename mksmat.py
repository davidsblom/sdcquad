"""Generate pre-computed SDC integration matrices."""

# Copyright (c) 2011, 2012.  Matthew Emmett and Ricardo Ortiz.  All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#   1. Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#   2. Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials provided
#      with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.


import sdcquad as sdc

# compute "refined" S matrices too?
compute_refinements = True

# set number of digits
digits = 35


##
## set global mpmath precision
##

from sympy.mpmath import mp
from sympy.mpmath import nstr
mp.dps    = digits
mp.pretty = True


##
## compute sdc nodes and smats
##

# build a dictionary (quads) for the various quadrature types:
#
# * G:  Gauss-Legendre,
# * U:  Uniform,
# * GL: Gauss-Lobatto,
# * GR: Gauss-Radau, and
# * CC: Clenshaw-Curtis

quads = {}
for q in [ 'G', 'GL', 'GR', 'CC' ]:
  quads[q] = {}

  # start with n0 nodes, and double the nodes maxsteps times
  for n0, maxsteps in [ (2, 4), (4, 2) ]:
    n = n0
    refine = [ 1 ]

    for i in range(maxsteps+1):
      quads[q][n] = {}

      for r in refine:
        print q, n, r
        try:
          (nodes, left) = sdc.nodes(q, n)
          smat = sdc.smat(nodes[::r], left)
          quads[q][n][r] = (nodes, smat)
        except:
          print 'SKIPPED'
          pass

      if compute_refinements:
        refine.append(2**(i+1))

      n = 2*n-1


##
## write fortran module 'quadrature.f90'
##

def fstr(x):
  s = nstr(x, n=digits)
  s = s.replace('e', 'd')
  if s.find('d') == -1:
    s = s + 'd0'
  return s


with open('quadrature.f90', 'w') as f:
  f.write('! this file was generated by "mksmat.py"\n')
  f.write('module quadrature\ncontains\n')

  for q in quads:
    subroutine = 'sdcquad%s' % q
    f.writelines([ 'subroutine %s(nnodes, refine, smat, nodes)\n' % subroutine,
                   'implicit none\n',
                   'integer, intent(in)  :: nnodes, refine\n',
                   'real(8), intent(out) :: smat((nnodes-1)/refine,(nnodes-1)/refine+1)\n',
                   'real(8), intent(out) :: nodes((nnodes-1)/refine+1)\n',
                   '\n',
                   'select case(nnodes)\n' ])

    for n in quads[q]:
      f.writelines(['case(%d)\n' % n,
                    '  select case(refine)\n'])

      for r in quads[q][n]:
        f.writelines(['  case(%d)\n' % r])

        (nodes, smat) = quads[q][n][r]
        for k, node in enumerate(nodes):
          f.write('    nodes(%d) = %s\n' % (k+1, fstr(node)))

        for i, row in enumerate(smat):
          for j, entry in enumerate(row):
            f.write('    smat(%d,%d) = %s\n'
                    % (i+1, j+1, fstr(entry)))

      f.writelines(['  end select\n'])


    f.writelines([ 'end select\n',
                   'end subroutine %s\n' % subroutine ])

  f.write('end module quadrature\n\n')


##
## write python module 'quadrature.py'
##

with open('quadrature.py', 'w') as f:
  f.write('# this file was generated by "mksmat.py"\n')
  f.write('table = {\n')

  for q in quads:
    for n in quads[q]:
      for r in quads[q][n]:
        f.write("('%s',%d,%d): {\n" % (q, n, r))
        (nodes, smat) = quads[q][n][r]

        f.write("  'nodes': [" + ',\n'.join(
          [nstr(x, digits) for x in nodes]) + '],\n')
        f.write("  'matrix': [ \n")
        for row in smat:
          f.write('[' + ',\n'.join([nstr(x, digits) for x in row]) + '],\n')
        f.write("  ] }, \n")

  f.write('}\n\n')

##
## write C++ look-up tables '*.hpp' (no refinements)
##

# First rename quadratures.
quads['gauss_lobatto'] = quads['GL']
del quads['GL']
quads['gauss_radau'] = quads['GR']
del quads['GR']
quads['clenshaw_curtis'] = quads['CC']
del quads['CC']

for q in [ 'gauss_lobatto', 'gauss_radau', 'clenshaw_curtis' ]:
    subroutine = '%s_quadrature_' % q
    with open('%s.hpp' % q, 'w') as f:
        f.write('#ifndef %s_HPP\n' % q.upper())
        f.write('#define %s_HPP\n\n' % q.upper())
        f.write('// this file was generated by "mksmat.py"\n')
        f.write('#include<cassert>\n\n')
        f.write('namespace detail{\n\n')
        f.write('    template<int sdcnodes>\n')
        f.write('    inline long double %smatrix(unsigned i, unsigned j);\n\n' % subroutine)
        f.write('    template<int sdcnodes>\n')
        f.write('    inline long double %snode(unsigned i);\n\n' % subroutine)
        f.write('    template<int sdcnodes>\n')
        f.write('    inline long double %sdt(unsigned i);\n\n' % subroutine)

        for n in quads[q]:
            dt = mp.matrix(1, n-1)
            for r in quads[q][n]:
                f.write('    template<>\n')
                f.writelines(['    inline long double %smatrix<%d>(unsigned i, unsigned j)\n    {\n' % (subroutine, n),
                '        static long double integration_matrix[%d][%d] = \n        {\n' % (n-1, n)
                            ])
                (nodes, smat) = quads[q][n][r]
                rows, cols = smat.shape
                for row in range(rows):
                    dt[row] = sum(smat[row])
                    f.write('            {')
                    for col in range(cols-1):
                        f.write('%sL,' % str(smat[row][col]))
                    f.write('%sL}' % str(smat[row][cols-1]))
                    if row == rows-1:
                        f.write('\n        };\n')
                    else:
                        f.write(',\n')
                f.write('        return integration_matrix[i][j];\n')
                f.write('    } // %smatrix<%d>(i,j)\n\n' % (subroutine, n))

                f.write('    template<>\n')
                f.writelines(['    inline long double %snodes<%d>(unsigned i)\n    {\n' % (subroutine, n),
                              '        static long double integration_nodes[%d] = {' % n])
                for i in range(n-1):
                    f.write('%sL,' % str(nodes[i]))
                f.write('%sL};\n' % str(nodes[n-1]))
                f.write('        return integration_nodes[i];\n')
                f.write('\n    }// %snodes<%d>(i)\n\n' % (subroutine, n))

                f.write('    template<>\n')
                f.writelines(['    inline long double %sdt<%d>(unsigned i)\n    {\n' % (subroutine,n),
                              '        static long double integration_dt[%d] = {' % (n-1)])
                for i in range(n-2):
                    f.write('%sL,' % str(dt[i]))
                f.write('%sL};\n' % str(dt[n-2]))
                f.write('        return integration_dt[i];\n')
                f.write('\n    }// %sdt<%d>(i)\n\n' % (subroutine, n))

        f.write('} // namespace detail \n\n')
        f.write('template<typename value_type, int sdc_nodes>\n')
        class_name = q[0:q.find('_')].capitalize()+q[q.find('_')+1:].capitalize()
        f.write('struct %s\n{\n'% class_name)
        f.write('    inline value_type matrix(int i, int j)\n')
        f.write('    {\n')
        f.write('        assert(i < sdc_nodes-1 && j < sdc_nodes);\n')
        f.write('        return static_cast<value_type>(detail::%smatrix<sdc_nodes>(i,j));\n' % subroutine)
        f.write('    }\n\n')
        f.write('    inline value_type node(int i)\n')
        f.write('    {\n')
        f.write('        assert(i < sdc_nodes);\n')
        f.write('        return static_cast<value_type>(detail::%snode<sdc_nodes>(i));\n' % subroutine)
        f.write('    }\n\n')
        f.write('    inline value_type dt(int i)\n')
        f.write('    {\n')
        f.write('        assert(i < sdc_nodes-1);\n')
        f.write('        return static_cast<value_type>(detail::%sdt<sdc_nodes>(i));\n' % subroutine)
        f.write('    }\n')

        f.write('};\n\n')
        f.write('#endif\n')
